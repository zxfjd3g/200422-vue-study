<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>03_计算属性和监视</title>
</head>
<body>
<!--
1. 计算属性
  在computed中定义计算属性方法根据已有的数据进行计算返回一个要显示的新数据
  在页面中使用{{计算属性名}}来显示返回的数据
  computed VS method: 内部有缓存, 多处读取只计算一次
  计算属性默认相当于只有getter来根据已有数据计算返回一个新数据值, 也可以指定setter来监视我们主动修改当前计算属性值

2. 监视/侦听器
  通过watch配置或vm的$watch()来监视指定的属性值的变化
  当属性变化时, 回调函数自动调用, 在函数内部进行特定处理
  watch VS computed
    如果是根据已有数据, 来动态同步确定一个新的数据值那一般都选择computed
    watch可以做异步操作(如ajax请求)后才确定新的数据值
    watch还有一个很大特点可以对数组或对象数据进行深度(deep)监视  ===> 后面练习用
-->
<div id="demo">
  <!-- 
    模板中读取属性数据和执行函数都是找的vm对象
    模板中从来不用写this或vm
   -->
  姓: <input type="text" placeholder="First Name" v-model="firstName"><br>
  名: <input type="text" placeholder="Last Name" v-model="lastName"><br>
  <p>姓名(复杂的插值表达式): {{firstName + '-' + lastName}}</p>
  <p>姓名(方法): {{getFullName()}}</p>
  <p>姓名(方法): {{getFullName()}}</p>
  <p>姓名(计算属性): {{fullName1}}</p>
  <p>姓名(计算属性): {{fullName1}}</p>
</div>

<script type="text/javascript" src="../js/vue.js"></script>
<script type="text/javascript">
  new Vue({
    el: '#demo',
    data () {
      return {
        firstName: 'A',
        lastName: 'B',
        // fullName1: 'A-B'
      }
    },

    // 定义计算属性
    computed: {

      /* 
      1. 什么时候执行?   初始显示执行第一次 / 一旦依赖数据发生改变就会再次执行
      2. 用来做什么的? 将执行返回的结果作为计算属性值
      3. this是谁? this是vm对象   ===> 只要是vue控制的回调函数都是vm对象
      */
      fullName1 () {
        console.log('computed fullName1')
        return this.firstName + '-' + this.lastName
      }
    },

    methods: { // methods中所有的方法都会成为vm的方法
      getFullName () {
        console.log('getFullName()', this)  // this就是vm
        return this.firstName + '-' + this.lastName
      }
    },
  })

  /* 
  确定回调函数的3个问题
  1. 什么时候执行?
  2. 用来做什么的?
  3. this是谁?
  */
</script>
</body>
</html>